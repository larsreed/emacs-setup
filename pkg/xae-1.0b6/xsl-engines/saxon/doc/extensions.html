<html>

<head>

<title>SAXON Extensions</title>

<style type="text/css">

	H1 {
	    font-family: Arial, Helvetica, sans-serif;
	    font-size: 16pt;
	    font-weight: bold;
	    color: "#FF0080"
	}

	H2 {
	    font-family: Arial, Helvetica, sans-serif;
	    font-size: 14pt;
	    font-weight: bold;
	    color: "#FF0080"
	}

	H3 {
	    font-family: Arial, Helvetica, sans-serif;
	    font-size: 12pt;
	    font-weight: bold;
	    color: black;
	}

    P,LI,TD {
	    font-family: Arial, Helvetica, sans-serif;
	    font-size: 10pt;
	    font-weight: normal;
	    color: black;       
	}

    CODE {
	    font-family: Courier, monospace;
	    font-size: 12pt;
	    font-weight: normal;
	    color: black;       
	}

</style>
</head>


<body leftmargin="150" bgcolor="#ddeeff"><font face="Arial, Helvetica, sans-serif">

<div align=right><a href="index.html">SAXON home page</a></div>

<b><font FACE="Arial, Helvetica, sans-serif" SIZE="4">

<h1><big>SAXON Extensions</big></h1>


<p>This page describes the extension functions and extension elements supplied with the
SAXON product.</p>

<p>If you want to implement your own extensions,
 see <a href="extensibility.html">extensibility.html</a>.</p>

<p>These extension functions and elements have been provided because there are things that are difficult
to achieve, or inefficient, using standard XSLT facilities alone. As always, it is best to stick to
standard if you possibly can: and most things <i>are</i> possible, even if it's not obvious at first
sight.</p>

<table width="723">
  <tr>
    <td  colspan="3" width="719" bgcolor="#0000FF"><font color="#FFFFFF"><big><b>Contents</b></big></font></td>
  </tr>

  <tr>
    <td VALIGN="top"  bgcolor="#00FFFF" width="33%">
    <a href="#extension attributes"><b>Extension attributes</b></a><br>
    <a href="#trace">saxon:trace</a><br>
    <a href="#allow-avt">saxon:allow-avt</a><br>
    <a href="#disable">saxon:disable-output-escaping</a><br>
    <a href="#method">xsl:output method</a>
    </td>

    <td VALIGN="top"  bgcolor="#00FFFF" width="33%">
    <a href="#extension functions"><b>Extension functions</b></a><br>
    <a href="#difference">saxon:difference()</a><br>
    <a href="#distinct">saxon:distinct()</a><br>
    <a href="#evaluate">saxon:evaluate()</a><br>
    <a href="#exists">saxon:exists()</a><br>
    <a href="#expression">saxon:expression()</a><br>
    <a href="#forall">saxon:forAll()</a><br>
    <a href="#getuserdata">saxon:getUserData()</a><br>
    <a href="#hassamenodes">saxon:hasSameNodes()</a><br>  
    <a href="#highest">saxon:highest()</a><br>
    <a href="#if">saxon:if()</a><br>
    <a href="#ifnull">saxon:ifNull()</a><br>
    <a href="#intersection">saxon:intersection()</a><br>    
    <a href="#leading">saxon:leading()</a><br>    
    <a href="#linenumber">saxon:lineNumber()</a><br>  
    <a href="#lowest">saxon:lowest()</a><br>
    <a href="#max">saxon:max()</a><br>
    <a href="#min">saxon:min()</a><br>
    <a href="#nodeset">saxon:nodeSet()</a><br>
    <a href="#path">saxon:path()</a><br>
    <a href="#range">saxon:range()</a><br>
    <a href="#getuserdata">saxon:setUserData()</a><br>
    <a href="#sum">saxon:sum()</a><br>
    <a href="#systemid">saxon:systemId()</a><br>
    <a href="#tokenize">saxon:tokenize()</a><br>
    </td>
    
    <td VALIGN="top" bgcolor="#00FFFF">
    <a href="#extension elements"><b>Extension elements</b></a><br>
    <a href="#saxon:assign">saxon:assign</a><br>
    <a href="#saxon:doctype">saxon:doctype</a><br>
    <a href="#saxon:entity-ref">saxon:entity-ref</a><br>
    <a href="#saxon:function">saxon:function</a><br>
    <a href="#saxon:group">saxon:group</a><br>
    <a href="#saxon:handler">saxon:handler</a><br>
    <a href="#saxon:item">saxon:item</a><br>
    <a href="#saxon:output">saxon:output</a><br>
    <a href="#saxon:preview">saxon:preview</a><br>
    <a href="#saxon:return">saxon:return</a><br>
    <a href="#saxon:while">saxon:while</a><br>
    </td>
  </tr>
</table>

<a name="extension attributes"><h2>Extension attributes</h2></a>

<p>An extension attribute is an extra attribute on an XSL-defined element. Following the rules
of XSLT, such attributes must be in a non-default namespace. For SAXON extension elements,
the namespace must be the SAXON namespace URI "http://icl.com/saxon"</p>

<p>For example, the saxon:trace attribute can be set as follows:

<pre><code>
&lt;xsl:template match="item" saxon:trace="yes" xmlns:saxon="http://icl.com/saxon"&gt;
</code></pre>

<p>The extension attributes supplied with the SAXON product are as follows:</p>

<table>

<a name="trace"></a>
<tr><td valign="top" width="40%"><b>saxon:trace</b></td>
<td>This attribute may be set on the xsl:stylesheet element or the xsl:template element.
If set to the value "yes", it causes
execution of template rules to be traced to the standard error output. If present on xsl:stylesheet,
all template rules are traced; otherwise only selected templates are traced. When present on xsl:stylesheet,
it also outputs a list of all the top-level elements in the expanded stylesheet, along with their import
precedence.</td></tr>

<a name="allow-avt"></a>
<tr><td valign="top" width="40%"><b>saxon:allow-avt</b></td>
<td>This attribute may be set on the xsl:call-template element.
If set to the value "yes", it causes the name attribute of xsl:call-template to be
interpreted as an attribute value template. This allows the selection of the called template
to be decided at run-time. Typical usage is:<br>
 <b>&lt;xsl:call-template name="{$tname}" saxon:allow-avt="yes"&gt;</b></td></tr>

<a name="disable"></a>
<tr><td valign="top" width="40%"><b>saxon:disable-output-escaping</b></td>
<td>This attribute may be set on the xsl:attribute element.
If set to the value "yes", it causes the value of the attribute to be output as-is, without
any escaping of special characters. This affects both regular XML escaping of characters such
as ampersand, less-than, and quotes, and also the special escaping applied to URL attributes
in the HTML output method, whereby non-ASCII characters are replaced by %XX. Typical usage:<br>
 <b>&lt;xsl:attribute name="href" saxon:disable-output-escaping="yes"&gt;servlet?x=2&amp;amp;y=3&lt/xsl:attribute&gt;</b></td></tr>

</table>

<a name="method"></a>
<p>The <b>method</b> attribute of xsl:output and saxon:output can take the standard values "xml",
"html", or "text", or a <i>QName</i>.</p>

<p>If a QName is specified, the local name may be:</p>

<ul>
<li>the value "fop", which directs output to James Tauber's
FOP processor (which must be installed separately)</li>

<li>the value "xhtml", which outputs the result tree in XHTML format.
This follows the same rules as
method="xml", except that it follows the guidelines for making the XML acceptable to legacy HTML
browsers. Specifically (a) empty elements such as &lt;br/&gt; are output as &lt;br/&gt;, and
(b) empty elements such as &lt;p/&gt; are output as &lt;p&gt;&lt;/p&gt;. The indent attribute
defaults to "yes", and indenting follows the HTML rather than XML rules. Other attributes may
be specified as for XML output, e.g. cdata-section-elements and omit-xml-declaration.</li>

<li>the fully-qualified
class name of a class that implements either the SAX org.xml.sax.DocumentHandler interface, or the
SAX2 org.xml.sax.ContentHandler interface, or the
com.icl.saxon.output.Emitter interface. If such a value is specified,
output is directed to the user-supplied class.</li>
</ul>

<p> The prefix of the <i>QName</i> must correspond to a valid
namespace URI. It is recommended to use the SAXON URI "http://icl.com/saxon",
but this is not enforced.</p>


<hr>

<a name="extension functions"><h2>Extension functions</h2></a>

<p>A SAXON extension function is invoked using a name such as <b>saxon:localname()</b>.</p>

<p>The <b>saxon</b> prefix (or whatever prefix you choose to use) must be associated with the
SAXON namespace URI "http://icl.com/saxon" or (for backwards compatibility) any URI ending
with "/com.icl.saxon.functions.Extensions". </p>

<p>For example, to invoke the node-set function, write:</p>

<p><code><pre>
&lt;xsl:variable name="fragment">value&lt;/xsl:variable>
..
&lt;xsl:apply-templates
     select="saxon:node-set($fragment)"
     mode="postprocess"
     xmlns:saxon="http://icl.com/saxon"/>
</pre></code></p>


<p>The extension functions supplied with the SAXON product are as follows:</p>

<table>


<tr><td valign="top" width="40%"><a name="difference"></a><b>difference(node-set-1, node-set-2)</b></td>
<td>This returns a node-set that is the difference of the two supplied node-sets, that is, it contains
all the nodes that are in node-set-1 that are not also in node-set-2. </td></tr>


<tr><td valign="top"><a name="distinct"></a><b>distinct(node-set-1, [stored-expression])</b></td>
<td><p>This returns a node-set obtained by eliminating nodes in node-set-1 that have duplicate
values for the supplied stored expression, evaluated as a string. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function. If no stored expression is supplied, the default is
expression('.'), that is, the string-value of the node. If several nodes produce the same string value,
the one that is first in document order will be retained.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1.<p/>

<p>Example: &lt;xsl:for-each select="saxon:distinct(surname, saxon:expression('substring(.,1,1)')"&gt; will
process the first surname starting with each letter of the alphabet in turn.</td></tr>

<tr><td valign="top"><a name="eval"></a><b>eval(stored-expression)</b></td>
<td><p>This returns the result of evaluating the supplied stored expression.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated in the current context, that is, the context node is the current
node, and the context position and context size are the same as the result of calling position() or last()
respectively.<p/>

<p>Example: saxon:eval(saxon:expression(concat(2, $op, 2)))</td></tr>


<tr><td valign="top"><a name="evaluate"></a><b>evaluate(string)</b></td>
<td>The supplied string must contain an XPath expression. The result of the function is the result of
evaluating the XPath expression. This is useful where an expression needs to be constructed
at run-time or passed to the stylesheet as a parameter, for example where the sort key is determined
dynamically. The context for the expression (e.g. which variables and namespaces are available)
is exactly the same as if the expression were written explicitly at this point in the stylesheet.
The function saxon:evaluate(string) is shorthand for saxon:eval(saxon:expression(string)).</td></tr>


<tr><td valign="top"><a name="exists"></a><b>exists(node-set-1, stored-expression)</b></td>
<td><p>This returns true if the supplied stored expression evaluates to true for some 
node in node-set-1, when evaluated as a boolean. Otherwise it returns false.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1.<p/>

<p>Example: <b>saxon:exists(sale, saxon:expression('@price * @qty &amp;gt; 1000'))</b> will return true
if the context node has a child &lt;sale&gt; element for which the product of price and qty exceeds 1000.</td></tr>




<tr><td valign="top"><a name="expression"></a><b>expression(string)</b></td>
<td>The supplied string must contain an XPath expression. The result of the function is a <i>stored
expression</i>, which may be supplied as an argument to other extension functions such as
<a href="#eval">saxon:eval()</a>, <a href="#sum">saxon:sum()</a> and <a href="#sum">saxon:distinct()</a>. The result of
the expression will usually depend on the current node. The expression may contain references to
variables that are in scope at the point where saxon:expression() is called: these variables will be replaced
in the stored expression with the values they take at the time saxon:expression() is called, not the
values of the variables at the time the stored expression is evaluated.
Similarly, if the expression contains namespace prefixes, these are interpreted
in terms of the namespace declarations in scope at the point where the saxon:expression() function is
called, not those in scope where the stored expression is evaluated.</td></tr>

<tr><td valign="top"><a name="forall"></a><b>forall(node-set-1, stored-expression)</b></td>
<td><p>This returns true if the supplied stored expression evaluates to true for every 
node in node-set-1, when evaluated as a boolean. Otherwise it returns false.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1.<p/>

<p>Example: <b>saxon:forAll(sale, saxon:expression('@price * @qty &amp;gt; 1000'))</b> will return true
if for every child &lt;sale&gt; element of the context node, the product of price and qty exceeds 1000.</td></tr>


<tr><td valign="top" width="40%"><a name="getuserdata"></a><b>getUserData(string)</b></td>
<td>This returns user data associated with the context node in the source document. The user data
must be set up previously using the <a href="#setuserdata">saxon:setUserData()</a> function.</td></tr>

<tr><td valign="top"><a name="hassamenodes"></a><b>hasSameNodes(node-set-1, node-set-2)</b></td>
<td>This returns a boolean that is true if and only if node-set-1 and node-set-2 contain the same
set of nodes. Note this is quite different from the "=" operator, which tests whether there is a
pair of nodes with the same string-value.</td></tr>


<tr><td valign="top"><a name="highest"></a><b>highest(node-set-1 [, stored-expression])</b></td>
<td><p>This returns (as a node-set) the node from node-set-1 that has the highest value of
the supplied stored expression, evaluated as a number. If the stored expression is
omitted, the expression "number(.)" is evaluated: that is, the string value of the node, converted
to a number. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is an empty node-set. If several nodes have the highest value, the result node-set contains the
one that is first in document order.<p/>

<p>Example: saxon:highest(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the node for which this has the highest
 value.</td></tr>



<tr><td valign="top"><a name="if"></a><b>if(condition, value-1, value-2)</b></td>
<td>The first argument is evaluated as a boolean; if it is true, the function returns the value
value-1, if it is false, it returns value-2. The value may be of any type. Both the second and
third arguments are evaluated even though only one of the values is used.</td>
</tr>


<tr><td valign="top"><a name="ifnull"></a><b>ifNull(java-object)</b></td>
<td>The first argument must be a Java object wrapper returned from an external Java function.
The function returns true if the wrapped Java object is null.</td>
</tr>


<tr><td valign="top"><a name="intersection"></a><b>intersection(node-set-1, node-set-2)</b></td>
<td>This returns a node-set that is the intersection of the two supplied node-sets, that is, it contains
all the nodes that are in both sets. Note that the union operation can be done using the built-in
operator "|"</td></tr>


<tr><td valign="top"><a name="leading"></a><b>leading(node-set-1, stored-expression)</b></td>
<td><p>This returns a node-set containing all those nodes from node-set-1 up to and excluding the
first one (in document order) for which the stored-expression evaluates to false.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1 (taken in document
order), and with the context size equal to the size of node-set-1.<p/>

<p>Example: <b>saxon:leading(following-sibling::*, saxon:expression('self::para'))</b> will return 
the &lt;para&gt; elements following the current node, stopping at the first element that is not a
&lt;para&gt;.</td></tr>



<tr><td valign="top"><a name="linenumber"></a><b>lineNumber()</b></td>
<td>This returns the line number of the context node in the source document within the entity
that contains it. There are no arguments. If line numbers are not maintained for the current
document, the function returns -1. (To ensure that line numbers are maintained, use the -l
option on the command line)</td>
</tr>


<tr><td valign="top"><a name="lowest"></a><b>lowest(node-set-1 [, stored-expression])</b></td>
<td><p>This returns (as a node-set) the node from node-set-1 that has the lowest value of
the supplied stored expression, evaluated as a number. If the stored expression is
omitted, the expression "number(.)" is evaluated: that is, the string value of the node, converted
to a number. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is an empty node-set. If several nodes have the lowest value, the result node-set contains the
one that is first in document order.<p/>

<p>Example: saxon:lowest(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the node for which this has the lowest
 value.</td></tr>



<tr><td valign="top"><a name="max"></a><b>max(node-set-1 [, stored-expression])</b></td>
<td><p>This returns the maximimum value of a numeric expression resulting from evaluating the supplied stored expression for each
node in node-set-1 in turn, as a number. If the stored expression is
omitted, the expression "number(.)" is evaluated: that is, the string value of the node, converted
to a number. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is negative infinity.<p/>

<p>Example: saxon:max(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the maximum amount.</td></tr>


<tr><td valign="top"><a name="min"></a><b>min(node-set-1 [, stored-expression])</b></td>
<td><p>This returns the minimum value of a numeric expression resulting from evaluating the supplied stored expression for each
node in node-set-1 in turn, as a number. If the stored expression is
omitted, the expression "number(.)" is evaluated: that is, the string value of the node, converted
to a number. A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1. Any NaN values are ignored. If the node-set is empty, the result
is positive infinity.<p/>

<p>Example: saxon:min(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the minimum amount.</td></tr>


<tr><td valign="top" width="40%"><a name="nodeset"></a><b>nodeSet($fragment)</b></td>
<td><i>This function is now obsolete: a result-tree-fragment is now converted implicitly
to a node-set if it is used in a context where a node-set is required.</i>
The function takes a single argument that is a result tree fragment.
Its function is to convert the result tree fragment to a node-set. The resulting node-set contains a single
node, which is a root node (class DocumentInfo); below this are the actual nodes added to the result tree
fragment, which may be element nodes, text nodes, or anything
else. Note that a result tree fragment is not in general a well-formed document, for example there may
be multiple element nodes or text nodes as children of the root.</td></tr>



<tr><td valign="top" width="40%"><a name="path"></a><b>path()</b></td>
<td>This takes no arguments. It returns a string whose value is an XPath expression identifying
 the context node in the
source tree. This can be useful for diagnostics, or to create an XPointer value, or when generating
another stylesheet to process the same document. The resulting string can be used as input to the
evaluate() function, provided that any namespace prefixes it uses are declared.</td></tr>



<tr><td valign="top"><a name="range"></a><b>range(number-1, number-2)</b></td>
<td>The two arguments are converted to numbers and then rounded to integers. A new node-set is
constructed containing one node for each integer in the range number-1 to number-2 inclusive; if
number-2 is less than number-1 the result will be empty. The string-value of each node will be the
relevant number; for example range(2, 5) generates a set of four nodes with string-values "2", "3",
"4", and "5". The main intended usage is &lt;xsl:for-each select="range($from, $to)"&gt; which simulates
a conventional for loop in other programming languages.</td></tr>


<tr><td valign="top" width="40%"><a name="setuserdata"></a><b>setUserData(string, value)</b></td>
<td>This function sets user data associated with the context node in the source document. The data
may be retrieved later (during the same stylesheet execution only) using the
<a href="#getuserdata">saxon:getUserData()</a> function. The string serves as a name for this
property, allowing multiple pieces of user data to be associated with the same node. The value
may be any XPath value. This function returns an empty string as its nominal result.
<b>Note:</b> setUserData() is particularly useful to save data read during preview mode processing
(see <a href="#saxon:preview">saxon:preview</a>) for later use during normal processing. However, take
care (a) not to store the data with a node that will be deleted after the preview, and (b) not to
store a node-set containing nodes that will be deleted after the preview. It is safest
to store simple values such as strings and numbers: use the string() or number() function if necessary
to do the conversion.</td></tr>


<tr><td valign="top"><a name="sum"></a><b>sum(node-set-1, stored-expression)</b></td>
<td><p>This returns the total resuling from evaluating the supplied stored expression for each
node in node-set-1 in turn, as a number. If the result is NaN for any node, the total will be NaN.
A stored expression may be obtained as the result of calling
the <a href="#expression">saxon:expression()</a> function.</p>

<p>The stored expression is evaluated for each node in node-set-1 in turn, with that node as the context
node, with the context position equal to the position of that node in node-set-1, and with the context size
equal to the size of node-set-1.<p/>

<p>Example: saxon:sum(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the total amount.</td></tr>



<tr><td valign="top"><a name="systemid"></a><b>systemId()</b></td>
<td>This returns the system identifier (URI) of the entity in the
source document that contains the context node . There are no arguments.</td>
</tr>


<tr><td valign="top"><a name="tokenize"></a><b>tokenize(string-1, string-2?)</b></td>
<td>The first argument is converted to a string and is treated as a list of separated tokens.
If the second argument is present, any character in string-2 is taken as a delimiter character,
and any sequence of delimiter characters is taken as a token separator. If the second argument
is omitted, any sequence of whitespace is taken as a token separator: or to put it another way,
the default for string-2 is '&amp;#x09;&amp;#x0A;&amp;#x0D;&amp;#x20;'.<br> 
A new node-set is constructed containing one node for each token; if the string is empty or
 contains a separator only then the result will be empty. The string-value of each node will be the
relevant token; for example tokenize("a cup of tea") generates a set of four nodes with
 string-values "a", "cup", "of", and "tea". </td></tr>
</table>


</p>



<p>The source code of these methods, which in most cases is extremely simple,
 can be used as an example for writing
other user extension functions. It is found in class com.icl.saxon.functions.Extensions</p>

<hr>
<a name="Extension elements"><h2>Extension elements</h2></a>

<p>A SAXON extension element is invoked using a name such as <b>&lt;saxon:localname&gt;</b>.</p>

<p>The <b>saxon</b> prefix (or whatever prefix you choose to use) must be associated with the
SAXON namespace URI "http://icl.com/saxon". The prefix must also be designated as an
extension element prefix by including it in the
<b>extension-element-prefixes</b> attribute on the xsl:stylesheet element, or the
<b>xsl:extension-element-prefixes</b> attribute on any enclosing literal result element or
extension element.</p></p>

<p>However, top-level elements such as saxon:handler and saxon:preview can be used without
designating the prefix as an extension element prefix.</p>


<hr>

<h3><a name="saxon:assign">saxon:assign</a></h3>

<p>The <b>saxon:assign</b> element is used to change the value of a local or global variable that
has previously been declared using xsl:variable (or xsl:param). The variable or parameter
must be marked as assignable by including the extra attribute saxon:assignable="yes"</p>

<p>As with xsl:variable, the name of the variable is given in the mandatory <b>name</b> attribute,
and the new value may be given either by an expression in the <b>select</b> attribute, or by expanding
the content of the saxon:assign element</p>

<p>Example:</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:variable name="i" select="0" saxon:assignable="yes"/&gt;
&lt;saxon:while test="$i &amp;lt; 10"&gt;
    The value of i is &lt;xsl:value-of select="$i"/&gt;
    &lt;saxon:assign name="i" select="$i+1"/&gt;
&lt;/saxon:while>
    </pre></font></td>
  </tr>
</table>



<hr>

<h3><a name="saxon:doctype">saxon:doctype</a></h3>

<p>The <b>saxon:doctype</b> instruction is used to insert a document type declaration into the
current output file. It must be instantiated before the first element in the output file is written.</p>

<p>The saxon:doctype instruction takes no attributes. The content of the element is a template-body
that is instantiated to create an XML document that represents the DTD to be generated; this XML
document is then serialized using a special output method that produces DTD syntax rather than
XML syntax.</p>

<p>If this element is present the doctype-system and doctype-public attributes of xsl:output are
ignored</p>

<p>The generated XML document uses the following elements, where the namespace prefix "dtd" is
used for the namespace URI "http://icl.com/saxon/dtd":</p>

<table>

<tr><td valign="top" width="30%"/>dtd:doctype</td>
<td>Represents the document type declaration. This is always the top-level element. The element
may contain dtd:element, dtd:attlist, dtd:entity, and dtd:notation elements. It may have the following
attributes:<br />
<b>name</b> (mandatory) The name of the document type<br />
<b>system</b> The system ID<br />
<b>public</b> The public ID
</td></tr>

<tr><td valign="top" width="30%"/>dtd:element</td>
<td>Represents an element type declaration. This is always a child of dtd:doctype. The element
is always empty. It may have the following attributes:<br />
<b>name</b> (mandatory) The name of the element type<br />
<b>content</b> (mandatory) The content model, exactly as it appears in a DTD, for example
content="(#PCDATA)" or content="( a | b | c)*"<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:attlist</td>
<td>Represents an attribute list declaration. This is always a child of dtd:doctype. The element
will generally have one or more dtd:attribute children. It may have the following attributes:<br />
<b>element</b> (mandatory) The name of the element type<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:attribute</td>
<td>Represents an attribute declaration within an attribute list.
 This is always a child of dtd:attlist. The element
will always be empty. It may have the following attributes:<br />
<b>name</b> (mandatory) The name of the attribute<br />
<b>type</b> (mandatory) The type of the attribute, exactly as it appears in a DTD, for example
type="ID" or type="( red | green | blue)"<br />
<b>value</b> (mandatory) The default value of the attribute, exactly as it appears in a DTD, for example
value="#REQUIRED" or value="#FIXED 'blue'"<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:entity</td>
<td>Represents an entity declaration.
 This is always a child of dtd:doctype. The element may be empty, or it may have content. The
 content is a template body, which is instantiated to define the value of an internal parsed
 entity. Note that this value includes the delimiting quotes. The xsl:entity element
  may have the following attributes:<br />
<b>name</b> (mandatory) The name of the entity<br />
<b>system</b> The system identifier<br />
<b>public</b> The public identifier<br />
<b>parameter</b> Set to "yes" for a parameter entity<br />
<b>notation</b> The name of a notation, for an unparsed entity<br />
</td></tr>

<tr><td valign="top" width="30%"/>dtd:notation</td>
<td>Represents a notation declaration.
 This is always a child of dtd:doctype. The element will always be empty. It
  may have the following attributes:<br />
<b>name</b> (mandatory) The name of the notation<br />
<b>system</b> The system identifier<br />
<b>public</b> The public identifier<br />
</td></tr>

</table>

<p>Note that Saxon will perform only minimal validation on the DTD being generated; it will
output the components requested but will not check that this generates well-formed XML, let
alone that the output document instance is valid according to this DTD.</p>


<p>Example:</p>



<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match="/"&gt;
  &lt;saxon:doctype xsl:extension-element-prefixes="saxon">
  &lt;dtd:doctype name="booklist"
        xmlns:dtd="http://icl.com/saxon/dtd" xsl:exclude-result-prefixes="dtd">
    &lt;dtd:element name="booklist" content="(book)*"/>
    &lt;dtd:element name="book" content="EMPTY"/>
    &lt;dtd:attlist element="book">
      &lt;dtd:attribute name="isbn" type="ID" value="#REQUIRED"/>
      &lt;dtd:attribute name="title" type="CDATA" value="#IMPLIED"/>
    &lt;/dtd:attlist>
    &lt;dtd:entity name="blurb">'A &lt;i>cool&lt;/i> book with &amp;gt; 200 pictures!'&lt;/dtd:entity>
    &lt;dtd:entity name="cover" system="cover.gif" notation="GIF"/>
    &lt;dtd:notation name="GIF" system="http://gif.org/"/>
  &lt;/dtd:doctype>
  &lt;/saxon:doctype>
  &lt;xsl:apply-templates/>
&lt;/xsl:template></pre></font></td>
  </tr>
</table>

<p>Although not shown in this example, there is nothing to stop the DTD being generated as the
output of a transformation, using instructions such as xsl:value-of and xsl:call-template.
It is also possible to use xsl:text with disable-output-escaping="yes" to output DTD constructs not
covered by this syntax, for example conditional sections and references to parameter entities.</p>






<hr>

<h3><a name="saxon:entity-ref">saxon:entity-ref</a></h3>


<p>The saxon:entity-ref element is useful to generate entities such as &amp;nbsp; in HTML output.
 To do this, write:</p>

<p>
<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
        &lt;saxon:entity-ref name="nbsp"/&gt;
</pre></font></td>
  </tr>
</table>
</p>



<hr>

<h3><a name="saxon:function">saxon:function</a></h3>

<p>The <b>saxon:function</b> element is used to declare an extension function
implemented in the XSLT language.</p>

<p>This is a top-level element; its content is a template-body, optionally preceded by
one or more xsl:param elements.</p>

<p>There must be a <b>name</b> attribute; its value is a QName, and it must have a non-null
namespace URI.</p>

<p>The function definition will normally contain one or more <a href="#saxon:return">saxon:return</a>
instructions to define the return value; if the function exits without encountering
a saxon:return, the result is an empty string.</p>

<p>The parameters are interpreted positionally. If there are more parameters declared
using xsl:param than are supplied in the function call, the excess parameters take their
default values. It is an error to have more arguments in the function call than there are
parameters declared in the function body.</p>

<p>In a function call where the function name has a non-null namespace URI, the system
searches first for a matching saxon:function definition, then for an external Java function.
At present there are no particular rules for resolving duplicate function names using import
precedence: it is advisable to avoid having two functions with the same name.</p>

<p>Calling a function does not change the current node or the values of position() and last().</p>

<p>A function body may contain local variables in the same way as a template body.</p>

<p>Functions provide an alternative to named templates. The main differences are that the
syntax for calling them is simpler (it is a standard XPath function call) and that they
can return a value of any type.</p>

<p>A function is not allowed to write anything to the result tree. More precisely, it
is not allowed to write to the current output destination of the code that calls it.
It is, however, allowed to create a new result tree fragment within the code of the function,
 or a new saxon:output destination, and write to this. The reason for this restriction is that
 it is generally unpredictable when and how often a function will be called, especially
 if it is used inside a predicate, so it is safest for it to have no side-effects.</p>

<p>One particular use for XSLT extension functions is to provide wrappers for Java extension
functions, making them more convenient to call from XPath expressions. Another use is in contexts
where named templates cannot be called, for example in the expressions used to define a named key
 (xsl:key) or a sort key (xsl:sort), or in the predicate of a match pattern.</p>


<p>Example:</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;saxon:function name="my:initial">
    &lt;xsl:param name="size"/>
    &lt;saxon:return select="substring(.,1,$size)"/>
&lt;/saxon:function>

&lt;xsl:template match="text()">
    &lt;xsl:value-of select="my:initial(3)"/>
&lt;/xsl:template>

</pre></td></tr></table>



<hr>


<h3><a name="saxon:group">saxon:group</a></h3>


<p>The <b>&lt;saxon:group&gt;</b> element causes iteration over the nodes selected by a node-set expression.</p>

<p>There is a mandatory attribute, <b>select</b>, which defines
the nodes over which the statement will iterate. This is analogous to the select attribute of &lt;xsl:for-each&gt;</p>

<p>There is also a mandatory <b>group-by</b> attribute to control grouping. The value of this attribute is
a string expression, which is applied to each item selected by the <b>select</b> expression.
The XSL statements subordinate to the &lt;saxon:group&gt; element
are applied once to each group of consecutive source nodes selected by the select expression that have the
 same value for the group-by expression.<p>

<p>The &lt;saxon:group&gt; element may have one or more <b>&lt;xsl:sort&gt;</b> child elements to define the order of
 sorting. The sort keys are specified in major-to-minor order. Note that group-by does not itself cause sorting, but it can conveniently be used in conjunction
 with sorting. The group-by key will often be the same as the major sort key.</p>

<p>
The &lt;saxon:group&gt; element must contain somewhere within it an &lt;saxon:item&gt; element. The XSL instructions
outside the &lt;saxon:item&gt; element are executed only once for each group of consecutive elements with the
same value for the grouping key; the instructions within the saxon:item are executed once for each
individual item in the saxon:group selection. </p>

<p>The context for the select expression is the usual context for expressions within an XSL element, i.e. it
is based on the current node and current node list of the containing template body.</b>

<p>The context for the group-by expression is as if the expression were written inside the saxon:group loop.
If the select expression selects a node-set S, then for each node N within S, the group-by expression is evaluated
with N as the context node, with count(S) as the context size, and with the context position taking the values
 1..count(S) in turn. The context position represents the position of the node in the node-set <i>after sorting</i>.</p>

<p>If there is an &lt;xsl:sort&gt; element present, then the context for evaluating the sort key follows exactly
the same rules as for &lt;xsl:for-each&gt;. In particular, the context position is the position <i>before sorting</i>.</p>

<p>Within the &lt;saxon:group&gt; element, and also within the &lt;saxon:item&gt;; element, the context reflects the
 full node-set being processed (that is, the node-set selected by the select attribute).
 The context position is the position of the node within this node-set, and the
 context size is the size of this node-set. It is not possible to determine the size of an individual group, or the
 position of the current node within an individual group. The instructions preceding &lt;saxon:item&gt; are executed with
 the first node of a group as the current node, and the instructions following &lt;saxon:item&gt; are executed with
 the last node of a group as the current node.</p> 

<p>The expressions used for sorting and grouping can be any string expressions. The following are
particularly useful:</p>

<ul>
<li>element-name, e.g. TITLE: sorts or groups on the value of a child element</li>
<li>attribute-name, e.g. @CODE: sorts or groups on the value of an attribute</li>
<li>".": sorts or groups on the character content of the element</li>
<li>"name(.)": sorts or groups on the name of the element</li>
</ul>



<p>Example: This example groups the BOOK elements having the same AUTHOR.</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><xmp>
<xsl:template match="BOOKLIST">
    <h2>
        <saxon:group select="BOOK" group-by="AUTHOR">
            <xsl:sort select="AUTHOR"/>
            <h3>AUTHOR: <xsl:value-of select="AUTHOR"></h3>
            <saxon:item>
                <p>TITLE: <xsl:value-of select="TITLE"/></p>
            </saxon:item>
            <hr/>
        </saxon:group>          
    </h2>
</xsl:template></xmp>
    </font></td>
  </tr>
</table>
</div><font SIZE="2">



<hr>

<h3><a name="saxon:handler">saxon:handler</a></h3>


<p>The saxon:handler element is used at the top level of the stylesheet, in the same way as
xsl:template. It takes attributes match, mode, name, and priority in the same way as xsl:template,
and is considered along with all XSL templates when searching for a template to execute in response
to xsl:apply-templates or xsl:call-template. However, the action performed when a saxon:handler
is invoked is to call the user-written Java NodeHandler named in the mandatory <b>handler</b> attribute.</p>

<p>The Java node handler must be written as a subclass of com.icl.saxon.handlers.NodeHandler. It is
supplied with a Context parameter, which gives access to a wide range of information and services,
including the current context in the source document, any parameters on the call, and the Outputter
 object used to write to the result tree. The Context parameter also provides access to a method
 applyTemplates() which allows the Java node handler to make a call back to process XSLT templates
 in the stylesheet.</p>   


<hr>

<h3><a name="saxon:item">saxon:item</a></h3>


<p>The <b>saxon:item</b> element is always used within a <b>saxon:group</b> element.
The XSL instructions outside the saxon:item element are executed once for each group (that is, each
group of consecutive items with the same value for the group-by expression), while the XSL instructions
within the saxon:item element are executed once for each individual item.</p>

<p>See <a href=#saxon:group>saxon:group</a> for further details.</p>


<hr>


<h3><a name="saxon:output">saxon:output</a></h3>
<font FACE="Arial, Helvetica, sans-serif">

<p>The saxon:output element is used to define a new output destination. <i>This element is a proprietary
SAXON feature</i>. Output reverts to the previous destination when the saxon:output end tag is encountered.</p>

<p>The <b>file</b> attribute is used to direct the output  to a named file. The filename
    is an attribute value template: it 
    will often be parameterised, e.g. using the current element number. If the file does not exist,
    it will be created. With Java JDK 1.2 or later, if a directory containing the file does not
    exist, it too will be created.</p>

<p>The <b>next-in-chain</b> attribute is used to direct the output to another stylesheet. The
value is the URL of a stylesheet that should be used to process the output stream. In this case
the output stream must always be pure XML, and attributes that control the format of the output
(e.g. method, cdata-section-elements, etc) will have no effect.</p>

<p>The <b>user-data</b> attribute can contain any string value; it is made available to a user-defined
Emitter class named in the <b>method</b> attribute. The value can be accessed through the getUserData()
method of the OutputDetails object passed to the Emitter.It is an attribute value template, so the
value can be computed at run-time.</p>

<p>The <b>file</b> and <b>next-in-chain</b> attributes are mutually exclusive.
they can both be omitted: this will normally only be useful if a user-supplied Emitter class is defined
in the <b>method</b> attribute.</p>

<p>All the attributes of saxon:output may be written as attribute value templates, allowing the
value to be decided at run-time. For example, you can write method="{$method-param}".</p>

<p>The <b>indent</b> attribute accepts the values "yes" and "no" or an integer;
 the default is "3" for HTML and
"no" for XML. Setting it to "yes" causes the output to be indented, using an algorithm that doesn't
meet the strict rules in the spec for the xsl:output element, because it sometimes adds whitespace
in places where it shouldn't. The value can also be set to an integer indicating the amount
of indentation, for example indent="2" indents by two spaces. The default is three spaces.
</p>

<p>The other attributes are the same as on <a href="xsl-elements.html#xsl:output">xsl:output</a>,
except that attribute value templates may be used. If no value is specified, the default is the
value defined for the current output file.</p>

<p>Here is an example that uses saxon:output:</p>
<div align="left">

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:template match=&quot;preface&quot;&gt;
    &lt;saxon:output file="{$dir}\preface.html"&gt;
        &lt;html&gt;&lt;body bgcolor=&quot;#00eeee&quot;&gt;&lt;center&gt;
            &lt;xsl:apply-templates/&gt;
        &lt;/center&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt;
    &lt;/saxon:output&gt;
    &lt;a href="{$dir}\preface.html"&gt;Preface&lt;/a&gt;
&lt;/xsl:template&gt;</pre>
</font></td>
  </tr>
</table>
</div>


<p>Here the body of the preface is directed to a file called preface.html (prefixed
by a constant that supplies the directory name). Output then reverts to the previous destination,
where an HTML hyperlink to the newly created file is inserted.</p>


<hr>

<h3><a name="saxon:preview">saxon:preview</a></h3>


<p>The <b>saxon:preview</b> element is a top-level element used to identify elements in the
source document that will
be processed in <i>preview</i> mode. The purpose of preview mode is to enable XSLT processing
of very large documents that are too big to fit in memory: the idea is that subtrees of the
document can be processed and then discarded as soon as they are encountered.</p>

<p>There are two mandatory attributes: <b>mode</b> identifies the mode in which the relevant
templates will be applied, and <b>elements</b> is a space-separated list of element names that
will be processed in preview mode.</p>

<p>While the source XML document is being read, if an element end tag is encountered for
an element that is in the list of preview elements, the relevant template is found (using the normal
matching rules, with mode equal to the specified preview mode). This template is then executed.
After the template has completed execution, the child nodes of the preview element (but not the element
itself, nor its attributes) are deleted from the tree to save memory.</p>

<p>During the matching of a preview element and during the execution of the preview template,
 only part of the source document is visible. This part includes
the ancestors of the preview element, the descendants of the preview element, and
all nodes that precede the preview element in document order,
except for nodes that are descendants of another preview element.</p>

<p>Global variables are not available to a preview template. The supplied values of
global parameters are available, but not the default values of unsupplied parameters.</p>

<p>A preview template may write to
a secondary output destination using saxon:output, or it may set global variables using saxon:assign.
It can save information using the extension function <a href="#setuserdata">setUserData()</a>, which
can be accessed later using <a href="#getuserdata">getUserData()</a>. This is useful to save information
that would otherwise disappear when the subtree rooted at the preview element is deleted from the tree.
 The preview template may also write directly to the
principal output destination, but note that in this case each instantiation of the preview template
will produce a subtree immediately below the root of the output tree. Normally this means the output
document will have multiple element nodes as children of the root. This is not well-formed XML, but you
can easily construct a well-formed XML document by referencing this file as an external entity.</p>

<p>One simple use for saxon:preview is simply to delete unwanted parts of the tree to reduce
the amount of memory needed. In this case, just provide a preview template that does nothing.</p>

<p>Preview templates are called while the tree is being built. When the tree has been completely
built, it will contain the preview elements themselves, but any nodes that were descendants of the
preview elements will have been deleted. At this stage the stylesheet is applied to the root of the
tree, in "default" mode, in the normal way. If you don't want any further processing to take place
at this stage, write a root template that does nothing: &lt;xsl:template match="/"/&gt;.</p>

<hr>


<h3><a name="saxon:return">saxon:return</a></h3>


<p>The <b>saxon:return</b> element is an instruction that can only occur within a saxon:function
definition. It cannot occur within xsl:for-each, and it must not have any following sibling
instructions other than xsl:fallback. However, there can be more than one xsl:return instruction
in a function, for example one in each branch of an xsl:choose.</p>

<p>Instantiating a saxon:return element causes exit from the call of the enclosing
 saxon:function.</p>

<p>The saxon:return element has an optional <b>select</b> attribute, whose value is an
 XPath expression. If the select attribute is present, this expression is evaluated and its
 value constitutes the return value of the function. If it is absent, the content of the
 saxon:return element is instantiated and the result is returned as a result tree fragment.
 If the element is empty and has no select attribute, the function returns an empty string.</p>

<p>If a function completes without instantiating a saxon:return instruction, the return value
of the function is an empty string.</p>




<hr>




<h3><a name="saxon:while">saxon:while</a></h3>


<p>The <b>saxon:while</b> element is used to iterate while some condition is true.</p>

<p>The condition is given as a boolean expression in the mandatory test attribute. Because
this expression must change its value if the loop is to terminate, the condition will always
reference a variable that is updated somewhere in the loop using an saxon:assign element.</p>

<p>Example:</p>

<table border="1" width="100%" class="code">
  <tr>
    <td width="100%" bgcolor="#00FFFF"><font FACE="Courier New" SIZE="3"><pre>
&lt;xsl:variable name="i" expr="0"/&gt;
&lt;saxon:while test="$i &amp;lt; 10"&gt;
    The value of i is &lt;xsl:value-of select="$i"/&gt;
    &lt;saxon:assign name="i" expr="$i+1"/&gt;
&lt;/saxon:while>
    </pre></font></td>
  </tr>
</table>




<hr>
<p align="center"><a HREF="mailto:Michael.Kay@icl.com">Michael H. Kay</a> <br>
2 October 2000 </p>
</body>
</html>

